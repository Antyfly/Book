Тема: Структурные паттерны проектирования

Адаптер— это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. 

Применимость:

• Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения. 
• Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете. 

Преимущества

	• Отделяет и скрывает от клиента подробности преобразования различных интерфейсов. 

Недостатки 

	• Усложняет код программы из-за введения дополнительных классов. 
 
Мост—  структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

Применимость 

	• Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности (например, если класс может работать с разными системами баз данных). 
	• Когда класс нужно расширять в двух независимых плоскостях. 
	• Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы. 

Преимущества

• Позволяет строить платформо-независимые программы. 
• Скрывает лишние или опасные детали реализации от клиентского кода. 
• Реализует принцип открытости/закрытости. 

Недостатки 

Усложняет код программы из-за введения дополнительных классов. 
 
Компоновщик— это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект. 

Применимость 

• Когда вам нужно представить древовидную структуру объектов. 
• Когда клиенты должны единообразно трактовать простые и составные объекты. 

Преимущества 

• Упрощает архитектуру клиента при работе со сложным деревом компонентов. 
• Облегчает добавление новых видов компонентов. 

Недостатки 

• Создаёт слишком общий дизайн классов. 
 
Декоратор— это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки». 

Применимость
 
• Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует. 
• Когда нельзя расширить обязанности объекта с помощью наследования. 

Преимущества 

• Большая гибкость, чем у наследования. 
• Позволяет добавлять обязанности на лету. 
• Можно добавлять несколько новых обязанностей сразу. 
• Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни. 

Недостатки 

• Трудно конфигурировать многократно обёрнутые объекты. 
• Обилие крошечных классов. 
 
Фасад— это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку. 

Применимость 

• Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме. 
• Когда вы хотите разложить подсистему на отдельные слои. 

Преимущества 

• Изолирует клиентов от компонентов сложной подсистемы. 

Недостатки 

• Фасад рискует стать объектом, привязанным ко всем классам программы. 
 
Легковес— это структурный паттерн проектирования, который позволяет вместить большее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте. 

Применимость 

• Когда не хватает оперативной памяти для поддержки всех нужных объектов. 

Преимущества 

• Экономит оперативную память. 

Недостатки 

• Расходует процессорное время на поиск/вычисление контекста. 
• Усложняет код программы из-за введения множества дополнительных классов. 
 
Заместитель— это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу. 

Применимость 

• Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных. 
• Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные). 
• Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере. 
• Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту. 
• Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом. 

Преимущества 

• Позволяет контролировать сервисный объект незаметно для клиента. 
• Может работать, даже если сервисный объект ещё не создан. 
• Может контролировать жизненный цикл служебного объекта. 

Недостатки 

• Усложняет код программы из-за введения дополнительных классов. 
• Увеличивает время отклика от сервиса. 
 
Поведенческие паттерны проектирования 


Эти паттерны решают задачи эффективного и безопасного взаимодействия между объектами программы. 
 
Цепочка обязанностей— это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи. 

Применимость 

• Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся. 
• Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке. 
• Когда набор объектов, способных обработать запрос, должен задаваться динамически. 

Преимущества 

• Уменьшает зависимость между клиентом и обработчиками. 
• Реализует принцип единственной обязанности. 
• Реализует принцип открытости/закрытости. 

Недостатки
 
• Запрос может остаться никем не обработанным. 
 
Команда— это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
 
Применимость 

• Когда вы хотите параметризовать объекты выполняемым действием. 
• Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети. 
• Когда вам нужна операция отмены. 

Преимущества 

• Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют. 
• Позволяет реализовать простую отмену и повтор операций. 
• Позволяет реализовать отложенный запуск операций. 
• Позволяет собирать сложные команды из простых. 
• Реализует принцип открытости /закрытости. 

Недостатки 

• Усложняет код программы из-за введения множества дополнительных классов. 
 
Итератор— это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления. 

Применимость 

• Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности). 
• Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных. 
• Когда вам хочется иметь единый интерфейс обхода различных структур данных. 

Преимущества 

• Упрощает классы хранения данных. 
• Позволяет реализовать различные способы обхода структуры данных. 
• Позволяет одновременно перемещаться по структуре данных в разные стороны. 

Недостатки 

• Не оправдан, если можно обойтись простым циклом. 
 
Посредник— это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник. 
 
Применимость 

• Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами. 
• Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов. 
• Когда вам приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах. 

Преимущества 

• Устраняет зависимости между компонентами, позволяя повторно их использовать. 
• Упрощает взаимодействие между компонентами. 
• Централизует управление в одном месте. 

Недостатки 

• Посредник может сильно раздуваться. 
 
Снимок— это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.
 
Применимость 

1. Когда вам нужно сохранять мгновенные снимки состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии. 
2. Когда прямое получение состояния объекта раскрывает приватные детали его реализации, нарушая инкапсуляцию.
 
Преимущества 

• Не нарушает инкапсуляции исходного объекта. 
• Упрощает структуру исходного объекта. Ему не нужно хранить историю версий своего состояния. 

Недостатки 

• Требует много памяти, если клиенты слишком часто создают снимки. 
• Может повлечь дополнительные издержки памяти, если объекты, хранящие историю, не освобождают ресурсы, занятые устаревшими снимками. 
• В некоторых языках сложно гарантировать, чтобы только исходный объект имел доступ к состоянию снимка. 
 
Наблюдатель— это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах. 

Применимость 

	• Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать. 
	• Когда одни объекты должны наблюдать за другими, но только в определённых случаях. 
	
Преимущества 

	• Издатели не зависят от конкретных классов подписчиков и наоборот. 
	• Вы можете подписывать и отписывать получателей на лету. 
	• Реализует принцип открытости/закрытости. 
	
Недостатки 

	• Подписчики оповещаются в случайном порядке. 
 
Состояние— это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта. 

Применимость 

	• Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется. 
	• Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса. 
	• Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов. 
	
Преимущества 

	• Избавляет от множества больших условных операторов машины состояний. 
	• Концентрирует в одном месте код, связанный с определённым состоянием. 
	• Упрощает код контекста. 
	
Недостатки 

• Может неоправданно усложнить код, если состояний мало и они редко меняются. 
 
Стратегия— это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы. 

Применимость 

• Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта. 
• Когда у вас есть множество похожих классов, отличающихся только некоторым поведением. 
• Когда вы не хотите обнажать детали реализации алгоритмов для других классов. 
• Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора представляет собой вариацию алгоритма. 

Преимущества 

• Горячая замена алгоритмов на лету. 
• Изолирует код и данные алгоритмов от остальных классов. 
• Уход от наследования к делегированию. 
• Реализует принцип открытости/закрытости. 

Недостатки 

• Усложняет программу за счёт дополнительных классов. 
• Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую. 
 
 
Шаблонный метод— это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры. 

Применимость 

• Когда подклассы должны расширять базовый алгоритм, не меняя его структуры. 
• Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы. 

Преимущества 

• Облегчает повторное использование кода.

Недостатки 

• Вы жёстко ограничены скелетом существующего алгоритма. 
• Вы можете нарушить принцип подстановки Барбары Лисков, изменяя базовое поведение одного из шагов алгоритма через подкласс. 
• С ростом количества шагов шаблонный метод становится слишком сложно поддерживать. 
 
Посетитель— это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться. 

Применимость 

• Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом. 
• Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями. 
• Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии. 

Преимущества 

• Упрощает добавление операций, работающих со сложными структурами объектов. 
• Объединяет родственные операции в одном классе. 
• Посетитель может накапливать состояние при обходе структуры элементов.
•  
Недостатки 

• Паттерн не оправдан, если иерархия элементов часто меняется. 
• Может привести к нарушению инкапсуляции элементов. 